// This file was autogenerated by the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

import {
  ArrayBufferDataStream,
  FfiConverter,
  FfiConverterArrayBuffer,
  FfiConverterInt8,
  FfiConverterUInt8,
  FfiConverterInt16,
  FfiConverterUInt16,
  FfiConverterInt32,
  FfiConverterUInt32,
  FfiConverterInt64,
  FfiConverterUInt64,
  FfiConverterFloat32,
  FfiConverterFloat64,
  FfiConverterBoolean,
  FfiConverterBytes,
  FfiConverterString,
  UniFFICallbackHandler,
  UniFFICallbackMethodHandler,
  UniFFIError,
  UniFFIInternalError,
  UniFFITypeError,
  constructUniffiObject,
  handleRustResult,
  uniffiObjectPtr,
} from "moz-src:///toolkit/components/uniffi-js/js/UniFFI.sys.mjs";

// Objects intended to be used in the unit tests
export var UnitTestObjs = {
    uniffiObjectPtr,
};


/**
 * Enumeration for the different types of device.
 * 
 * Firefox Accounts separates devices into broad categories for display purposes,
 * such as distinguishing a desktop PC from a mobile phone. Upon signin, the
 * application should inspect the device it is running on and select an appropriate
 * [`DeviceType`] to include in its device registration record.
 */
export const DeviceType = {
    /**
     * DESKTOP
     */
    DESKTOP: 0,
    /**
     * MOBILE
     */
    MOBILE: 1,
    /**
     * TABLET
     */
    TABLET: 2,
    /**
     * VR
     */
    VR: 3,
    /**
     * TV
     */
    TV: 4,
    /**
     * UNKNOWN
     */
    UNKNOWN: 5,
};
Object.freeze(DeviceType);

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeDeviceType extends FfiConverterArrayBuffer {
    static #validValues = Object.values(DeviceType)

    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return DeviceType.DESKTOP
            case 2:
                return DeviceType.MOBILE
            case 3:
                return DeviceType.TABLET
            case 4:
                return DeviceType.VR
            case 5:
                return DeviceType.TV
            case 6:
                return DeviceType.UNKNOWN
            default:
                throw new UniFFITypeError("Unknown DeviceType variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value === DeviceType.DESKTOP) {
            dataStream.writeInt32(1);
            return;
        }
        if (value === DeviceType.MOBILE) {
            dataStream.writeInt32(2);
            return;
        }
        if (value === DeviceType.TABLET) {
            dataStream.writeInt32(3);
            return;
        }
        if (value === DeviceType.VR) {
            dataStream.writeInt32(4);
            return;
        }
        if (value === DeviceType.TV) {
            dataStream.writeInt32(5);
            return;
        }
        if (value === DeviceType.UNKNOWN) {
            dataStream.writeInt32(6);
            return;
        }
        throw new UniFFITypeError("Unknown DeviceType variant");
    }

    static computeSize(value) {
        return 4;
    }

    static checkType(value) {
      // Check that the value is a valid enum variant
      if (!this.#validValues.includes(value)) {
          throw new UniFFITypeError(`${value} is not a valid value for DeviceType`);
      }
    }
}




